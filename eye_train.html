<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lazy Eye Games - Working Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #7c2d12 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #ef4444, #3b82f6);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .mode-selector {
            background: rgba(31, 41, 55, 0.9);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .mode-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .mode-btn {
            padding: 12px 20px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(55, 65, 81, 0.5);
        }

        .mode-btn.active {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .glasses-notice {
            background: linear-gradient(135deg, #dc2626, #2563eb);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .glasses-notice.show {
            display: block;
        }

        .game-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .game-tab {
            padding: 10px 20px;
            background: rgba(55, 65, 81, 0.5);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .game-tab.active {
            background: #10b981;
        }

        .controls {
            background: rgba(31, 41, 55, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            align-items: end;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #10b981;
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .select,
        .color-picker {
            padding: 8px;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            width: 100%;
        }

        .color-picker {
            height: 40px;
            cursor: pointer;
        }

        .stats {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .stat {
            background: rgba(31, 41, 55, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            min-width: 80px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #10b981;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #d1d5db;
        }

        .game-area {
            background: #000;
            border: 3px solid #4b5563;
            border-radius: 12px;
            height: 500px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .game-area.active {
            border-color: #10b981;
        }

        /* Tetris Game */
        .tetris-container {
            display: none;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .tetris-container.active {
            display: flex;
        }

        .tetris-board {
            width: 300px;
            height: 400px;
            border: 2px solid #666;
            position: relative;
            background: #111;
            margin-bottom: 10px;
        }

        .tetris-block {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tetris-controls {
            color: white;
            text-align: center;
        }

        /* Breakout Game */
        .breakout-container {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .breakout-container.active {
            display: block;
        }

        .paddle {
            position: absolute;
            bottom: 30px;
            width: 100px;
            height: 15px;
            background: white;
            border-radius: 5px;
        }

        .ball {
            position: absolute;
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
        }

        .brick {
            position: absolute;
            width: 75px;
            height: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* Tracking Game */
        .tracking-container {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
            cursor: crosshair;
        }

        .tracking-container.active {
            display: block;
        }

        .target {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #10b981, #059669);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }

        .target:hover {
            transform: scale(1.1);
        }

        .crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

        .crosshair::before {
            width: 20px;
            height: 1px;
            left: -10px;
            top: 0;
        }

        .crosshair::after {
            width: 1px;
            height: 20px;
            left: 0;
            top: -10px;
        }

        .timer {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(31, 41, 55, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #10b981;
            font-weight: bold;
            display: none;
        }

        .timer.show {
            display: block;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #10b981;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .message.show {
            opacity: 1;
        }

        .instructions {
            background: rgba(31, 41, 55, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .mode-buttons {
                flex-direction: column;
                align-items: center;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .stats {
                flex-wrap: wrap;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üëÅÔ∏è Lazy Eye Training Games</h1>
            <p>Professional vision therapy with real gameplay</p>
        </div>

        <!-- Mode Selection -->
        <div class="mode-selector">
            <h3>Training Mode</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="standard">
                    üéÆ Standard Mode<br>
                    <small>No glasses needed</small>
                </button>
                <button class="mode-btn" data-mode="dichoptic">
                    ü•Ω Dichoptic Mode<br>
                    <small>3D glasses required</small>
                </button>
            </div>
        </div>

        <!-- Glasses Notice -->
        <div class="glasses-notice" id="glassesNotice">
            ü•Ω <strong>Put on your red-blue 3D glasses!</strong> Red filter on LEFT eye, blue filter on RIGHT eye.
        </div>

        <!-- Game Selection -->
        <div class="game-tabs">
            <button class="game-tab active" data-game="tetris">üß© Tetris Blocks</button>
            <button class="game-tab" data-game="breakout">üèì Breakout</button>
            <button class="game-tab" data-game="tracking">üéØ Target Tracking</button>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label>Session Time</label>
                <select class="select" id="sessionTime">
                    <option value="5">5 minutes</option>
                    <option value="10" selected>10 minutes</option>
                    <option value="20">20 minutes</option>
                    <option value="40">40 minutes</option>
                </select>
            </div>

            <div class="control-group">
                <label>Difficulty</label>
                <select class="select" id="difficulty">
                    <option value="1">Easy</option>
                    <option value="2" selected>Medium</option>
                    <option value="3">Hard</option>
                </select>
            </div>

            <div class="control-group" id="colorControls" style="display: none;">
                <label>Moving Color</label>
                <input type="color" class="color-picker" id="movingColor" value="#ff0000">
            </div>

            <div class="control-group" id="colorControls2" style="display: none;">
                <label>Static Color</label>
                <input type="color" class="color-picker" id="staticColor" value="#0000ff">
            </div>

            <div class="control-group">
                <button class="btn btn-primary" id="startBtn">üéÆ Start Game</button>
            </div>

            <div class="control-group">
                <button class="btn btn-danger" id="stopBtn" disabled>‚èπÔ∏è Stop Game</button>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="score">0</div>
                <div class="stat-label">Score</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="level">1</div>
                <div class="stat-label">Level</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="hits">0</div>
                <div class="stat-label">Hits</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="streak">0</div>
                <div class="stat-label">Streak</div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <!-- Tetris Game -->
            <div class="tetris-container active" id="tetrisGame">
                <div class="tetris-board" id="tetrisBoard"></div>
                <div class="tetris-controls">
                    <p>Use ‚Üê ‚Üí arrow keys to move, ‚Üì to drop faster</p>
                    <p><strong>SPACEBAR</strong> to rotate pieces, ‚Üë also rotates</p>
                    <p>Click falling blocks (red) to score points!</p>
                    <p><strong>Game Over</strong> when board fills to the top!</p>
                </div>
            </div>

            <!-- Breakout Game -->
            <div class="breakout-container" id="breakoutGame">
                <div class="paddle" id="paddle"></div>
                <div class="ball" id="ball"></div>
                <div class="crosshair"></div>
            </div>

            <!-- Tracking Game -->
            <div class="tracking-container" id="trackingGame">
                <div class="crosshair"></div>
                <div class="target" id="target"></div>
            </div>
        </div>

        <!-- Timer -->
        <div class="timer" id="timer">‚è±Ô∏è <span id="timeLeft">10:00</span></div>

        <!-- Message -->
        <div class="message" id="message">Great hit!</div>

        <!-- Instructions -->
        <div class="instructions">
            <h3>üéÆ How to Play</h3>
            <div
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 15px;">
                <div>
                    <h4 style="color: #60a5fa;">üß© Tetris Blocks</h4>
                    <ul style="padding-left: 20px;">
                        <li>Blocks fall from the top</li>
                        <li>Use arrow keys to move them</li>
                        <li>Click falling blocks to score</li>
                        <li>Landed blocks are different colors</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #60a5fa;">üèì Breakout</h4>
                    <ul style="padding-left: 20px;">
                        <li><strong>‚Üê ‚Üí arrow keys</strong> to move paddle (or mouse)</li>
                        <li>Keep ball bouncing</li>
                        <li>Hit bricks to score points</li>
                        <li><strong>Paddle sections:</strong> Left = bounce left, Right = bounce right, Center =
                            straight</li>
                        <li><strong>Lives:</strong> 3 lives, Game over if all lost or 3 consecutive misses</li>
                        <li>Ball and bricks use different colors</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #60a5fa;">üéØ Target Tracking</h4>
                    <ul style="padding-left: 20px;">
                        <li>Click on moving targets</li>
                        <li>Targets appear randomly</li>
                        <li>Quick reflexes = higher score</li>
                        <li>Trains eye movement control</li>
                    </ul>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 15px; background: rgba(16, 185, 129, 0.1); border-radius: 8px;">
                <strong>üí° Dichoptic Mode:</strong> In dichoptic mode with 3D glasses, moving objects appear in your
                weaker eye's color,
                while static objects appear in your stronger eye's color. This forces both eyes to work together!
            </div>
        </div>
    </div>

    <script>
        class LazyEyeGames {
            constructor() {
                this.mode = 'standard';
                this.currentGame = 'tetris';
                this.isActive = false;
                this.gameState = {
                    score: 0,
                    level: 1,
                    hits: 0,
                    streak: 0
                };
                this.settings = {
                    sessionTime: 10,
                    difficulty: 2,
                    movingColor: '#ff0000',
                    staticColor: '#0000ff'
                };
                this.intervals = {};

                // Key tracking for continuous movement
                this.keysPressed = {};

                // Game-specific state
                this.tetris = {
                    board: Array(16).fill().map(() => Array(10).fill(0)),
                    currentPiece: null,
                    pieces: []
                };

                this.breakout = {
                    paddle: { x: 400, width: 100 },
                    ball: { x: 400, y: 300, dx: 3, dy: 3 },
                    bricks: []
                };

                this.tracking = {
                    target: { x: 200, y: 200 },
                    lastMove: 0
                };

                this.init();
            }

            init() {
                this.bindEvents();
                this.setupGames();
            }

            bindEvents() {
                // Mode selection
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.selectMode(e.target.dataset.mode);
                    });
                });

                // Game tabs
                document.querySelectorAll('.game-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.selectGame(e.target.dataset.game);
                    });
                });

                // Controls
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopGame());

                document.getElementById('sessionTime').addEventListener('change', (e) => {
                    this.settings.sessionTime = parseInt(e.target.value);
                });

                document.getElementById('difficulty').addEventListener('change', (e) => {
                    this.settings.difficulty = parseInt(e.target.value);
                });

                document.getElementById('movingColor').addEventListener('change', (e) => {
                    this.settings.movingColor = e.target.value;
                    this.updateColors();
                });

                document.getElementById('staticColor').addEventListener('change', (e) => {
                    this.settings.staticColor = e.target.value;
                    this.updateColors();
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));

                // Mouse controls
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            selectMode(mode) {
                this.mode = mode;

                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

                const glassesNotice = document.getElementById('glassesNotice');
                const colorControls = document.getElementById('colorControls');
                const colorControls2 = document.getElementById('colorControls2');

                if (mode === 'dichoptic') {
                    glassesNotice.classList.add('show');
                    colorControls.style.display = 'block';
                    colorControls2.style.display = 'block';
                } else {
                    glassesNotice.classList.remove('show');
                    colorControls.style.display = 'none';
                    colorControls2.style.display = 'none';
                }

                this.updateColors();
            }

            selectGame(game) {
                this.currentGame = game;

                document.querySelectorAll('.game-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-game="${game}"]`).classList.add('active');

                document.querySelectorAll('.tetris-container, .breakout-container, .tracking-container').forEach(container => {
                    container.classList.remove('active');
                });
                document.getElementById(game + 'Game').classList.add('active');
            }

            updateColors() {
                if (this.mode === 'standard') return;

                // Apply dichoptic colors to game elements
                const movingColor = this.settings.movingColor;
                const staticColor = this.settings.staticColor;

                // Update existing elements
                document.querySelectorAll('.tetris-block.falling').forEach(block => {
                    block.style.backgroundColor = movingColor;
                });

                document.querySelectorAll('.tetris-block.landed').forEach(block => {
                    block.style.backgroundColor = staticColor;
                });

                const ball = document.getElementById('ball');
                const paddle = document.getElementById('paddle');
                if (ball) ball.style.backgroundColor = movingColor;
                if (paddle) paddle.style.backgroundColor = staticColor;

                document.querySelectorAll('.brick').forEach(brick => {
                    brick.style.backgroundColor = staticColor;
                });

                const target = document.getElementById('target');
                if (target) {
                    target.style.background = `radial-gradient(circle, ${movingColor}, ${this.darkenColor(movingColor, 20)})`;
                }
            }

            darkenColor(hex, percent) {
                const num = parseInt(hex.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max((num >> 16) - amt, 0);
                const G = Math.max((num >> 8 & 0x00FF) - amt, 0);
                const B = Math.max((num & 0x0000FF) - amt, 0);
                return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }

            setupGames() {
                this.setupTetris();
                this.setupBreakout();
                this.setupTracking();
            }

            setupTetris() {
                const board = document.getElementById('tetrisBoard');
                board.innerHTML = '';
                this.tetris.pieces = [];
                this.tetris.landedPieces = []; // Track landed pieces
                this.tetris.board = Array(16).fill().map(() => Array(10).fill(0));
                this.tetris.currentPiece = null;
                this.tetris.dropTime = 0;

                // Tetris piece shapes
                this.tetris.shapes = [
                    { // I-piece
                        blocks: [[1, 1, 1, 1]],
                        color: '#00f0f0'
                    },
                    { // O-piece
                        blocks: [[1, 1], [1, 1]],
                        color: '#f0f000'
                    },
                    { // T-piece
                        blocks: [[0, 1, 0], [1, 1, 1]],
                        color: '#a000f0'
                    },
                    { // S-piece
                        blocks: [[0, 1, 1], [1, 1, 0]],
                        color: '#00f000'
                    },
                    { // Z-piece
                        blocks: [[1, 1, 0], [0, 1, 1]],
                        color: '#f00000'
                    },
                    { // J-piece
                        blocks: [[1, 0, 0], [1, 1, 1]],
                        color: '#0000f0'
                    },
                    { // L-piece
                        blocks: [[0, 0, 1], [1, 1, 1]],
                        color: '#f0a000'
                    }
                ];
            }

            setupBreakout() {
                const container = document.getElementById('breakoutGame');
                const bricksContainer = container.querySelector('#bricks') || document.createElement('div');
                bricksContainer.id = 'bricks';
                if (!container.contains(bricksContainer)) {
                    container.appendChild(bricksContainer);
                }

                bricksContainer.innerHTML = '';
                this.breakout.bricks = [];

                // Get game area width to calculate proper brick layout
                const gameArea = document.getElementById('gameArea');
                const gameWidth = gameArea ? gameArea.offsetWidth : 800;

                // Calculate brick layout to fill the entire width
                const brickColumns = 11;
                const brickHeight = 20;
                const brickPadding = 5; // Space between bricks
                const sideMargin = 10; // Small margin on left and right

                // Calculate brick width to fill the container
                const availableWidth = gameWidth - (2 * sideMargin) - ((brickColumns - 1) * brickPadding);
                const brickWidth = Math.floor(availableWidth / brickColumns);

                // Create bricks - 11 columns for symmetry
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < brickColumns; col++) {
                        const brick = document.createElement('div');
                        brick.className = 'brick';

                        const brickX = sideMargin + (col * (brickWidth + brickPadding));
                        const brickY = 50 + (row * (brickHeight + 5));

                        brick.style.left = brickX + 'px';
                        brick.style.top = brickY + 'px';
                        brick.style.width = brickWidth + 'px';
                        brick.style.height = brickHeight + 'px';
                        brick.style.backgroundColor = this.mode === 'dichoptic' ? this.settings.staticColor : '#4ade80';
                        bricksContainer.appendChild(brick);

                        this.breakout.bricks.push({
                            element: brick,
                            x: brickX,
                            y: brickY,
                            width: brickWidth,
                            height: brickHeight,
                            active: true
                        });
                    }
                }

                // Reset ball and paddle with proper speeds
                const baseSpeed = 2 + this.settings.difficulty;
                this.breakout.ball = {
                    x: gameWidth / 2, // Center ball horizontally
                    y: 300,
                    dx: baseSpeed * (Math.random() > 0.5 ? 1 : -1),
                    dy: -baseSpeed,
                    radius: 7
                };

                this.breakout.paddle = {
                    x: (gameWidth - 100) / 2, // Center paddle
                    width: 100,
                    height: 15,
                    y: 465,
                    velocity: 0
                };
                this.breakout.lives = 3;
                this.breakout.consecutiveLosses = 0;
                this.breakout.prevPaddleX = this.breakout.paddle.x;

                const ball = document.getElementById('ball');
                const paddle = document.getElementById('paddle');
                if (ball) {
                    ball.style.left = (this.breakout.ball.x - this.breakout.ball.radius) + 'px';
                    ball.style.top = (this.breakout.ball.y - this.breakout.ball.radius) + 'px';
                    ball.style.backgroundColor = this.mode === 'dichoptic' ? this.settings.movingColor : 'white';
                }
                if (paddle) {
                    paddle.style.left = this.breakout.paddle.x + 'px';
                    paddle.style.backgroundColor = this.mode === 'dichoptic' ? this.settings.staticColor : 'white';
                }

                // Update lives display
                this.updateLivesDisplay();
            }

            updateLivesDisplay() {
                // Update the hits display to show lives instead
                document.getElementById('hits').textContent = this.breakout.lives || 3;
                const hitsLabel = document.querySelector('#hits').nextElementSibling;
                if (hitsLabel) {
                    hitsLabel.textContent = 'Lives';
                }
            }

            setupTracking() {
                this.moveTrackingTarget();
            }

            startGame() {
                this.isActive = true;
                this.gameState = { score: 0, level: 1, hits: 0, streak: 0 };

                // Reset game-specific state
                if (this.currentGame === 'breakout') {
                    this.setupBreakout();
                } else if (this.currentGame === 'tetris') {
                    this.setupTetris();
                } else if (this.currentGame === 'tracking') {
                    this.setupTracking();
                }

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('gameArea').classList.add('active');
                document.getElementById('timer').classList.add('show');

                this.startTimer();
                this.startGameLoop();

                this.showMessage('Game Started! üéÆ');
            }

            stopGame() {
                this.isActive = false;
                Object.values(this.intervals).forEach(interval => clearInterval(interval));

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('gameArea').classList.remove('active');
                document.getElementById('timer').classList.remove('show');

                this.showMessage(`Game Over! Final Score: ${this.gameState.score}`);
            }

            startTimer() {
                let timeLeft = this.settings.sessionTime * 60;

                this.intervals.timer = setInterval(() => {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    document.getElementById('timeLeft').textContent =
                        minutes + ':' + seconds.toString().padStart(2, '0');

                    timeLeft--;
                    if (timeLeft < 0) {
                        this.stopGame();
                    }
                }, 1000);
            }

            startGameLoop() {
                // Different speeds for different games
                let speed;
                switch (this.currentGame) {
                    case 'tetris':
                        speed = Math.max(100, 500 - (this.settings.difficulty * 100));
                        break;
                    case 'breakout':
                        speed = 16; // ~60 FPS for smooth ball movement
                        break;
                    case 'tracking':
                        speed = Math.max(100, 500 - (this.settings.difficulty * 100));
                        break;
                    default:
                        speed = 100;
                }

                this.intervals.gameLoop = setInterval(() => {
                    switch (this.currentGame) {
                        case 'tetris':
                            this.updateTetris();
                            break;
                        case 'breakout':
                            this.updateBreakout();
                            break;
                        case 'tracking':
                            this.updateTracking();
                            break;
                    }
                    this.updateStats();
                }, speed);
            }

            updateTetris() {
                const now = Date.now();

                // Create new piece if none exists
                if (!this.tetris.currentPiece) {
                    this.spawnTetrisPiece();
                    return;
                }

                // Drop piece every second (adjustable by difficulty)
                const dropInterval = Math.max(300, 1000 - (this.settings.difficulty * 200));
                if (now - this.tetris.dropTime > dropInterval) {
                    this.dropCurrentPiece();
                    this.tetris.dropTime = now;
                }
            }

            spawnTetrisPiece() {
                if (this.tetris.currentPiece) return; // Don't spawn if piece exists

                const board = document.getElementById('tetrisBoard');
                const shapeIndex = Math.floor(Math.random() * this.tetris.shapes.length);
                const shape = this.tetris.shapes[shapeIndex];

                const piece = {
                    shape: shape.blocks,
                    color: shape.color,
                    x: 4, // Center horizontally
                    y: 0,
                    elements: []
                };

                // Check if there's room for the new piece (game over check)
                if (!this.canPieceMoveTo(piece, piece.x, piece.y)) {
                    this.gameOver();
                    return;
                }

                // Create visual elements for this piece
                for (let row = 0; row < shape.blocks.length; row++) {
                    for (let col = 0; col < shape.blocks[row].length; col++) {
                        if (shape.blocks[row][col]) {
                            const block = document.createElement('div');
                            block.className = 'tetris-block falling';
                            block.style.width = '30px';
                            block.style.height = '25px';
                            block.style.position = 'absolute';
                            block.style.border = '1px solid rgba(255,255,255,0.3)';

                            // Apply colors based on mode
                            if (this.mode === 'dichoptic') {
                                block.style.backgroundColor = this.settings.movingColor;
                            } else {
                                block.style.backgroundColor = shape.color;
                            }

                            // Position the block
                            const pixelX = (piece.x + col) * 30;
                            const pixelY = (piece.y + row) * 25;
                            block.style.left = pixelX + 'px';
                            block.style.top = pixelY + 'px';

                            // Add click handler for scoring
                            block.onclick = () => this.handleTetrisClick(piece);

                            board.appendChild(block);
                            piece.elements.push({ element: block, row: row, col: col });
                        }
                    }
                }

                this.tetris.currentPiece = piece;
                this.tetris.dropTime = Date.now();
            }

            gameOver() {
                this.isActive = false;
                Object.values(this.intervals).forEach(interval => clearInterval(interval));

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('gameArea').classList.remove('active');
                document.getElementById('timer').classList.remove('show');

                const finalScore = this.gameState.score;
                const message = `üéÆ GAME OVER!\n\nBoard is full!\nFinal Score: ${finalScore}\nTotal Hits: ${this.gameState.hits}\nBest Streak: ${this.gameState.streak}`;

                setTimeout(() => {
                    alert(message);
                }, 500);

                this.showMessage('Game Over - Board Full!');
            }

            rotatePiece(piece) {
                if (!piece || !piece.shape) return false;

                // Create rotated shape (90 degrees clockwise)
                const oldShape = piece.shape;
                const newShape = [];
                const rows = oldShape.length;
                const cols = oldShape[0].length;

                // Rotate matrix 90 degrees clockwise
                for (let i = 0; i < cols; i++) {
                    newShape[i] = [];
                    for (let j = 0; j < rows; j++) {
                        newShape[i][j] = oldShape[rows - 1 - j][i];
                    }
                }

                // Test if rotated piece fits
                const testPiece = { ...piece, shape: newShape };
                if (this.canPieceMoveTo(testPiece, piece.x, piece.y)) {
                    // Remove old visual elements
                    piece.elements.forEach(blockData => {
                        if (blockData.element.parentNode) {
                            blockData.element.remove();
                        }
                    });

                    // Update piece shape
                    piece.shape = newShape;
                    piece.elements = [];

                    // Create new visual elements for rotated piece
                    const board = document.getElementById('tetrisBoard');
                    for (let row = 0; row < newShape.length; row++) {
                        for (let col = 0; col < newShape[row].length; col++) {
                            if (newShape[row][col]) {
                                const block = document.createElement('div');
                                block.className = 'tetris-block falling';
                                block.style.width = '30px';
                                block.style.height = '25px';
                                block.style.position = 'absolute';
                                block.style.border = '1px solid rgba(255,255,255,0.3)';

                                // Apply colors based on mode
                                if (this.mode === 'dichoptic') {
                                    block.style.backgroundColor = this.settings.movingColor;
                                } else {
                                    block.style.backgroundColor = piece.color;
                                }

                                // Position the block
                                const pixelX = (piece.x + col) * 30;
                                const pixelY = (piece.y + row) * 25;
                                block.style.left = pixelX + 'px';
                                block.style.top = pixelY + 'px';

                                // Add click handler for scoring
                                block.onclick = () => this.handleTetrisClick(piece);

                                board.appendChild(block);
                                piece.elements.push({ element: block, row: row, col: col });
                            }
                        }
                    }

                    return true;
                }

                return false;
            }

            dropCurrentPiece() {
                if (!this.tetris.currentPiece) return;

                const piece = this.tetris.currentPiece;
                const newY = piece.y + 1;

                // Check if piece can move down
                if (this.canPieceMoveTo(piece, piece.x, newY)) {
                    // Move piece down
                    piece.y = newY;
                    this.updatePieceVisuals(piece);
                } else {
                    // Piece has landed - convert to static
                    this.landCurrentPiece();
                }
            }

            canPieceMoveTo(piece, newX, newY) {
                // Check boundaries and collisions
                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            const finalX = newX + col;
                            const finalY = newY + row;

                            // Check boundaries
                            if (finalX < 0 || finalX >= 10 || finalY >= 16) {
                                return false;
                            }

                            // Check collision with landed pieces
                            if (finalY >= 0 && this.tetris.board[finalY][finalX]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            updatePieceVisuals(piece) {
                // Update position of all visual elements
                piece.elements.forEach(blockData => {
                    const pixelX = (piece.x + blockData.col) * 30;
                    const pixelY = (piece.y + blockData.row) * 25;
                    blockData.element.style.left = pixelX + 'px';
                    blockData.element.style.top = pixelY + 'px';
                });
            }

            landCurrentPiece() {
                if (!this.tetris.currentPiece) return;

                const piece = this.tetris.currentPiece;

                // Add piece to board grid
                const landedBlocks = [];
                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            const boardY = piece.y + row;
                            const boardX = piece.x + col;
                            if (boardY >= 0 && boardY < 16 && boardX >= 0 && boardX < 10) {
                                this.tetris.board[boardY][boardX] = {
                                    filled: true,
                                    element: piece.elements.find(e => e.row === row && e.col === col).element
                                };
                                landedBlocks.push({ row: boardY, col: boardX });
                            }
                        }
                    }
                }

                // Convert visual elements to landed pieces (keep them permanently)
                piece.elements.forEach(blockData => {
                    blockData.element.classList.remove('falling');
                    blockData.element.classList.add('landed');
                    blockData.element.onclick = null; // Remove click handler

                    // Change color for dichoptic mode
                    if (this.mode === 'dichoptic') {
                        blockData.element.style.backgroundColor = this.settings.staticColor;
                    } else {
                        // Darken the color for landed pieces
                        blockData.element.style.backgroundColor = this.darkenColor(piece.color, 30);
                    }
                });

                // Store landed pieces permanently
                if (!this.tetris.landedPieces) {
                    this.tetris.landedPieces = [];
                }
                this.tetris.landedPieces.push({
                    elements: piece.elements,
                    blocks: landedBlocks
                });

                // Clear the current piece
                this.tetris.currentPiece = null;

                // Check for completed lines
                this.checkForCompletedLines();
            }

            checkForCompletedLines() {
                let linesCleared = 0;
                const linesToClear = [];

                // Check each row from bottom to top
                for (let row = 15; row >= 0; row--) {
                    let isComplete = true;
                    for (let col = 0; col < 10; col++) {
                        if (!this.tetris.board[row][col] || !this.tetris.board[row][col].filled) {
                            isComplete = false;
                            break;
                        }
                    }

                    if (isComplete) {
                        linesToClear.push(row);
                    }
                }

                // Clear completed lines
                linesToClear.forEach(row => {
                    // Remove visual elements from completed line
                    for (let col = 0; col < 10; col++) {
                        if (this.tetris.board[row][col] && this.tetris.board[row][col].element) {
                            this.tetris.board[row][col].element.remove();
                        }
                    }

                    // Remove line from board and add empty line at top
                    this.tetris.board.splice(row, 1);
                    this.tetris.board.unshift(Array(10).fill(0));

                    // Move all visual elements above this line down
                    this.moveElementsDown(row);

                    linesCleared++;
                });

                if (linesCleared > 0) {
                    this.gameState.score += linesCleared * 100;
                    this.showMessage(`Line clear! +${linesCleared * 100} points`);
                }
            }

            moveElementsDown(clearedRow) {
                // Move all blocks above the cleared row down by one position
                const board = document.getElementById('tetrisBoard');
                const allBlocks = board.querySelectorAll('.tetris-block.landed');

                allBlocks.forEach(block => {
                    const currentTop = parseInt(block.style.top);
                    const currentRow = Math.floor(currentTop / 25);

                    // If this block was above the cleared row, move it down
                    if (currentRow < clearedRow) {
                        block.style.top = (currentTop + 25) + 'px';
                    }
                });
            }

            // Remove the clearOldPieces function since we don't want pieces to disappear
            clearOldPieces() {
                // This function now does nothing - pieces only disappear when lines are cleared
                return;
            }

            handleTetrisClick(piece) {
                if (!this.isActive || piece !== this.tetris.currentPiece) return;

                this.gameState.score += 25;
                this.gameState.hits++;
                this.gameState.streak++;

                // Remove the clicked piece immediately
                piece.elements.forEach(blockData => {
                    if (blockData.element.parentNode) {
                        blockData.element.remove();
                    }
                });

                this.tetris.currentPiece = null;
                this.showMessage('Nice catch! +25');
            }

            updateBreakout() {
                if (!this.isActive || this.currentGame !== 'breakout') return;

                const ball = this.breakout.ball;
                const paddle = this.breakout.paddle;

                // Update paddle movement first
                this.updatePaddleMovement();

                // Get actual game area dimensions
                const gameArea = document.getElementById('gameArea');
                const gameWidth = gameArea ? gameArea.offsetWidth : 800;
                const gameHeight = gameArea ? gameArea.offsetHeight : 500;

                // Ensure paddle stays within bounds (safety check)
                paddle.x = Math.max(0, Math.min(paddle.x, gameWidth - paddle.width));

                // Move ball with proper speed
                ball.x += ball.dx;
                ball.y += ball.dy;

                // Ball collision with side walls - use actual game width
                if (ball.x <= ball.radius || ball.x >= gameWidth - ball.radius) {
                    ball.dx = -ball.dx;
                    ball.x = Math.max(ball.radius, Math.min(ball.x, gameWidth - ball.radius)); // Keep in bounds
                }

                // Ball collision with top wall
                if (ball.y <= ball.radius) {
                    ball.dy = -ball.dy;
                    ball.y = ball.radius;
                }

                // Ball goes off bottom - lose a life
                if (ball.y >= gameHeight - 10) {
                    this.breakout.lives--;
                    this.breakout.consecutiveLosses++;
                    this.updateLivesDisplay();

                    if (this.breakout.lives <= 0) {
                        // Game Over - no lives left
                        this.breakoutGameOver('No lives remaining!');
                        return;
                    }

                    if (this.breakout.consecutiveLosses >= 3) {
                        // Game Over - 3 consecutive losses
                        this.breakoutGameOver('3 consecutive misses!');
                        return;
                    }

                    // Reset ball position
                    ball.x = gameWidth / 2;
                    ball.y = gameHeight / 2;
                    const baseSpeed = 2 + this.settings.difficulty;
                    ball.dx = (Math.random() > 0.5 ? 1 : -1) * baseSpeed;
                    ball.dy = -baseSpeed;

                    this.showMessage(`Life lost! ${this.breakout.lives} remaining`);
                }

                // Calculate paddle velocity
                if (this.breakout.prevPaddleX !== undefined) {
                    this.breakout.paddle.velocity = paddle.x - this.breakout.prevPaddleX;
                }
                this.breakout.prevPaddleX = paddle.x;

                // Improved paddle collision detection
                const paddleTop = paddle.y;
                const paddleBottom = paddle.y + paddle.height;
                const paddleLeft = paddle.x;
                const paddleRight = paddle.x + paddle.width;

                // Calculate ball bounds
                const ballLeft = ball.x - ball.radius;
                const ballRight = ball.x + ball.radius;
                const ballTop = ball.y - ball.radius;
                const ballBottom = ball.y + ball.radius;

                // Check if ball is colliding with paddle
                const horizontalOverlap = ballRight >= paddleLeft && ballLeft <= paddleRight;
                const verticalOverlap = ballBottom >= paddleTop && ballTop <= paddleBottom;

                // Only bounce if ball is moving down and overlapping paddle
                if (ball.dy > 0 && horizontalOverlap && verticalOverlap) {
                    // Place ball just above paddle to prevent sticking
                    ball.y = paddleTop - ball.radius - 1;

                    // Always bounce upward
                    ball.dy = -Math.abs(ball.dy);

                    // Calculate hit position on paddle (0 = left edge, 1 = right edge)
                    const hitPos = Math.max(0, Math.min(1, (ball.x - paddleLeft) / paddle.width));

                    // Determine bounce direction based on paddle section
                    if (hitPos < 0.33) {
                        // Left side - bounce left
                        ball.dx = -Math.abs(ball.dx) * 1.5 - 1;
                        this.showMessage('‚¨ÖÔ∏è Left edge hit!');
                    } else if (hitPos > 0.67) {
                        // Right side - bounce right
                        ball.dx = Math.abs(ball.dx) * 1.5 + 1;
                        this.showMessage('‚û°Ô∏è Right edge hit!');
                    } else {
                        // Middle - bounce more straight
                        ball.dx = ball.dx * 0.5 + (Math.random() - 0.5);
                        this.showMessage('‚¨ÜÔ∏è Center hit!');
                    }

                    // Add paddle velocity influence
                    ball.dx += this.breakout.paddle.velocity * 0.3;

                    // Ensure minimum vertical speed
                    const minVerticalSpeed = 2 + this.settings.difficulty * 0.5;
                    if (Math.abs(ball.dy) < minVerticalSpeed) {
                        ball.dy = -minVerticalSpeed;
                    }

                    // Limit total ball speed
                    const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    const maxSpeed = 4 + this.settings.difficulty * 1.5;
                    if (speed > maxSpeed) {
                        ball.dx = (ball.dx / speed) * maxSpeed;
                        ball.dy = (ball.dy / speed) * maxSpeed;
                    }

                    this.gameState.score += 5;
                    this.gameState.hits++;
                    this.breakout.consecutiveLosses = 0;
                }


                // Check if ball is in the paddle zone horizontally
                const ballInPaddleZone = (ball.x + ball.radius >= paddleLeft) &&
                    (ball.x - ball.radius <= paddleRight);

                // Check if ball crossed the paddle vertically (was above, now at or below)
                const ballCrossedPaddle = this.breakout.prevBallY + ball.radius < paddleTop &&
                    ball.y + ball.radius >= paddleTop;

                // Ball is moving downward and either overlapping or crossing paddle
                if (ball.dy > 0 && ballInPaddleZone &&
                    (ballCrossedPaddle || (ball.y + ball.radius >= paddleTop && ball.y - ball.radius <= paddleBottom))) {

                    // Force ball above paddle
                    ball.y = paddleTop - ball.radius;
                    ball.dy = -Math.abs(ball.dy); // Always bounce upward

                    // Calculate hit position on paddle (0 = left edge, 1 = right edge)
                    const hitPos = Math.max(0, Math.min(1, (ball.x - paddleLeft) / paddle.width));

                    // Determine bounce direction based on paddle section
                    if (hitPos < 0.33) {
                        // Left side - bounce left
                        ball.dx = -Math.abs(ball.dx) - 1;
                        this.showMessage('‚¨ÖÔ∏è Left edge hit!');
                    } else if (hitPos > 0.67) {
                        // Right side - bounce right
                        ball.dx = Math.abs(ball.dx) + 1;
                        this.showMessage('‚û°Ô∏è Right edge hit!');
                    } else {
                        // Middle - bounce more straight with slight random angle
                        ball.dx = ball.dx * 0.3 + (Math.random() - 0.5) * 2;
                        this.showMessage('‚¨ÜÔ∏è Center hit!');
                    }

                    // Limit ball speed to prevent it going crazy
                    var maxSpeed = 5;
                    ball.dx = Math.max(-maxSpeed, Math.min(maxSpeed, ball.dx));
                    ball.dy = Math.max(-maxSpeed, Math.min(-2, ball.dy)); // Ensure upward movement

                    this.gameState.score += 5;
                    this.gameState.hits++;
                    this.breakout.consecutiveLosses = 0; // Reset consecutive losses
                }

                // Store current position for next frame
                this.breakout.prevBallY = ball.y;

                // Ball collision with bricks
                this.breakout.bricks.forEach(brick => {
                    if (brick.active &&
                        ball.x + ball.radius >= brick.x &&
                        ball.x - ball.radius <= brick.x + 75 &&
                        ball.y + ball.radius >= brick.y &&
                        ball.y - ball.radius <= brick.y + 20) {

                        // Determine collision side for better physics
                        const overlapLeft = (ball.x + ball.radius) - brick.x;
                        const overlapRight = (brick.x + 75) - (ball.x - ball.radius);
                        const overlapTop = (ball.y + ball.radius) - brick.y;
                        const overlapBottom = (brick.y + 20) - (ball.y - ball.radius);

                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapTop || minOverlap === overlapBottom) {
                            ball.dy = -ball.dy;
                        } else {
                            ball.dx = -ball.dx;
                        }

                        brick.active = false;
                        brick.element.style.display = 'none';
                        this.gameState.score += 20;
                        this.gameState.hits++;
                        this.gameState.streak++;
                        this.breakout.consecutiveLosses = 0; // Reset consecutive losses
                        this.showMessage('Brick hit! +20');

                        // Check if all bricks are destroyed
                        const activeBricks = this.breakout.bricks.filter(b => b.active);
                        if (activeBricks.length === 0) {
                            this.gameState.score += 500;
                            this.breakout.lives++; // Bonus life for clearing level
                            this.updateLivesDisplay();
                            this.showMessage('Level cleared! +500 bonus + 1 life!');
                            // Reset bricks for next level
                            setTimeout(() => {
                                this.setupBreakout();
                            }, 1000);
                        }
                    }
                });

                // Update ball position
                const ballElement = document.getElementById('ball');
                if (ballElement) {
                    ballElement.style.left = (ball.x - ball.radius) + 'px';
                    ballElement.style.top = (ball.y - ball.radius) + 'px';
                }
            }

            breakoutGameOver(reason) {
                this.isActive = false;
                Object.values(this.intervals).forEach(interval => clearInterval(interval));

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('gameArea').classList.remove('active');
                document.getElementById('timer').classList.remove('show');

                const finalScore = this.gameState.score;
                const message = `üèì BREAKOUT GAME OVER!\n\n${reason}\nFinal Score: ${finalScore}\nTotal Hits: ${this.gameState.hits}\nBest Streak: ${this.gameState.streak}\n\nClick "Start Game" to play again!`;

                setTimeout(() => {
                    alert(message);
                }, 500);

                this.showMessage(`Game Over: ${reason}`);

                // Reset the game state for next play
                this.resetBreakoutGame();
            }

            resetBreakoutGame() {
                // Reset all game elements
                this.breakout = {
                    paddle: { x: 350, width: 100, y: 465 },
                    ball: { x: 400, y: 300, dx: 3, dy: -3, radius: 7 },
                    bricks: [],
                    lives: 3,
                    consecutiveLosses: 0
                };

                // Clear the game area
                const container = document.getElementById('breakoutGame');
                const existingBricks = container.querySelector('#bricks');
                if (existingBricks) {
                    existingBricks.innerHTML = '';
                }

                // Reset ball and paddle positions
                const ball = document.getElementById('ball');
                const paddle = document.getElementById('paddle');
                if (ball) {
                    ball.style.left = '400px';
                    ball.style.top = '300px';
                }
                if (paddle) {
                    paddle.style.left = '350px';
                }

                // Reset stats display
                document.getElementById('hits').textContent = '0';
                const hitsLabel = document.querySelector('#hits').nextElementSibling;
                if (hitsLabel) {
                    hitsLabel.textContent = 'Hits';
                }
            }

            updateTracking() {
                // Move target every 2 seconds
                if (Date.now() - this.tracking.lastMove > 2000) {
                    this.moveTrackingTarget();
                }
            }

            moveTrackingTarget() {
                const container = document.getElementById('trackingGame');
                const target = document.getElementById('target');
                if (!target || !container) return;

                const rect = container.getBoundingClientRect();
                const maxX = 760;
                const maxY = 460;

                const x = Math.random() * maxX + 20;
                const y = Math.random() * maxY + 20;

                this.tracking.target = { x, y };
                this.tracking.lastMove = Date.now();

                target.style.left = x + 'px';
                target.style.top = y + 'px';
                target.onclick = () => this.handleTargetClick();

                // Apply color
                if (this.mode === 'dichoptic') {
                    target.style.background = `radial-gradient(circle, ${this.settings.movingColor}, ${this.darkenColor(this.settings.movingColor, 20)})`;
                }
            }

            handleTargetClick() {
                if (!this.isActive) return;

                const responseTime = Date.now() - this.tracking.lastMove;
                let points = 15;

                // Bonus for quick response
                if (responseTime < 1000) points += 10;
                if (responseTime < 500) points += 15;

                this.gameState.score += points;
                this.gameState.hits++;
                this.gameState.streak++;

                this.showMessage(`Quick hit! +${points}`);
                this.moveTrackingTarget();
            }

            handleKeyPress(e) {
                if (!this.isActive) return;

                // Track which keys are pressed
                this.keysPressed[e.key] = true;

                if (this.currentGame === 'tetris' && this.tetris.currentPiece) {
                    const piece = this.tetris.currentPiece;

                    switch (e.key) {
                        case 'ArrowLeft':
                            if (this.canPieceMoveTo(piece, piece.x - 1, piece.y)) {
                                piece.x -= 1;
                                this.updatePieceVisuals(piece);
                            }
                            break;
                        case 'ArrowRight':
                            if (this.canPieceMoveTo(piece, piece.x + 1, piece.y)) {
                                piece.x += 1;
                                this.updatePieceVisuals(piece);
                            }
                            break;
                        case 'ArrowDown':
                            if (this.canPieceMoveTo(piece, piece.x, piece.y + 1)) {
                                piece.y += 1;
                                this.updatePieceVisuals(piece);
                                this.gameState.score += 1;
                            } else {
                                this.landCurrentPiece();
                            }
                            break;
                        case ' ': // Spacebar for rotation
                        case 'Space':
                            this.rotatePiece(piece);
                            break;
                        case 'ArrowUp': // Alternative rotation key
                            this.rotatePiece(piece);
                            break;
                    }
                    e.preventDefault();
                }

                // For breakout, we'll handle continuous movement in the game loop
                if (this.currentGame === 'breakout') {
                    e.preventDefault();
                }
            }

            handleKeyUp(e) {
                // Stop tracking released keys
                this.keysPressed[e.key] = false;
            }

            updatePaddleMovement() {
                if (this.currentGame !== 'breakout' || !this.isActive) return;

                const gameArea = document.getElementById('gameArea');
                const gameWidth = gameArea ? gameArea.offsetWidth : 800;
                const paddleSpeed = 8; // Fast continuous movement

                // Handle continuous paddle movement
                if (this.keysPressed['ArrowLeft']) {
                    this.breakout.paddle.x = Math.max(0, this.breakout.paddle.x - paddleSpeed);
                }
                if (this.keysPressed['ArrowRight']) {
                    this.breakout.paddle.x = Math.min(gameWidth - this.breakout.paddle.width,
                        this.breakout.paddle.x + paddleSpeed);
                }

                // Update paddle visual position
                const paddleElement = document.getElementById('paddle');
                if (paddleElement) {
                    paddleElement.style.left = this.breakout.paddle.x + 'px';
                }
            }

            handleMouseMove(e) {
                if (!this.isActive || this.currentGame !== 'breakout') return;

                const gameArea = document.getElementById('gameArea');
                const rect = gameArea.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;

                // Get actual game area width
                const gameWidth = rect.width;
                const paddleWidth = this.breakout.paddle.width;

                // Update paddle position - ensure it stays within boundaries
                // Clamp between 0 and (gameWidth - paddleWidth)
                const targetX = mouseX - paddleWidth / 2;
                this.breakout.paddle.x = Math.max(0, Math.min(targetX, gameWidth - paddleWidth));

                const paddleElement = document.getElementById('paddle');
                if (paddleElement) {
                    paddleElement.style.left = this.breakout.paddle.x + 'px';
                }
            }

            updatePaddleMovement() {
                if (this.currentGame !== 'breakout' || !this.isActive) return;

                const gameArea = document.getElementById('gameArea');
                const gameWidth = gameArea ? gameArea.offsetWidth : 800;
                const paddleSpeed = 8; // Fast continuous movement
                const paddleWidth = this.breakout.paddle.width;

                // Handle continuous paddle movement with proper boundaries
                if (this.keysPressed['ArrowLeft']) {
                    this.breakout.paddle.x = Math.max(0, this.breakout.paddle.x - paddleSpeed);
                }
                if (this.keysPressed['ArrowRight']) {
                    this.breakout.paddle.x = Math.min(gameWidth - paddleWidth, this.breakout.paddle.x + paddleSpeed);
                }

                // Update paddle visual position
                const paddleElement = document.getElementById('paddle');
                if (paddleElement) {
                    paddleElement.style.left = this.breakout.paddle.x + 'px';
                }
            }

            updateStats() {
                document.getElementById('score').textContent = this.gameState.score;
                document.getElementById('level').textContent = Math.floor(this.gameState.score / 100) + 1;
                document.getElementById('hits').textContent = this.gameState.hits;
                document.getElementById('streak').textContent = this.gameState.streak;
            }

            showMessage(text) {
                const message = document.getElementById('message');
                message.textContent = text;
                message.classList.add('show');

                setTimeout(() => {
                    message.classList.remove('show');
                }, 1500);
            }
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new LazyEyeGames();
        });
    </script>
</body>

</html>